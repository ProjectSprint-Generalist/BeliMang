// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5/pgtype"
)

type MerchantQueryParams struct {
	MerchantID       string
	Name             string
	MerchantCategory string
	CreatedAt        string
	Limit            int32
	Offset           int32
}

type MerchantQueryResult struct {
	ID               pgtype.UUID
	Name             string
	MerchantCategory MerchantCategory
	ImageURL         string
	Lat              float64
	Long             float64
	CreatedAt        pgtype.Timestamptz
}

type MerchantItemParam struct {
	ID              string
	MerchantID      string
	Name            string
	ProductCategory ProductCategory
	Price           int32
	CreatedAt       string
}

func (q *Queries) GetMerchants(ctx context.Context, arg MerchantQueryParams) ([]MerchantQueryResult, error) {
	baseQuery := `
		SELECT
			m.ID,
			m.Name,
			m.MerchantCategory,
			COALESCE(i.ImageURL, '') as ImageURL,
			ST_Y(m.Location::geometry) as Lat,
			ST_X(m.Location::geometry) as Long,
			m.CreatedAt
		FROM Merchant m
		LEFT JOIN Image i ON m.ImageID = i.ID
	`

	counter := 1
	var conditions []string
	var args []interface{}

	// Filter by merchantId
	if arg.MerchantID != "" {
		conditions = append(conditions, fmt.Sprintf("m.ID = $%d", counter))
		args = append(args, arg.MerchantID)
		counter++
	}

	// Filter by name with wildcard search (case insensitive)
	if arg.Name != "" {
		conditions = append(conditions, fmt.Sprintf("LOWER(m.Name) LIKE LOWER($%d)", counter))
		args = append(args, "%"+arg.Name+"%")
		counter++
	}

	// Filter by merchantCategory
	if arg.MerchantCategory != "" {
		conditions = append(conditions, fmt.Sprintf("m.MerchantCategory = $%d", counter))
		args = append(args, arg.MerchantCategory)
		counter++
	}

	// Build WHERE clause
	if len(conditions) > 0 {
		baseQuery += " WHERE " + strings.Join(conditions, " AND ")
	}

	// Sort by createdAt
	if arg.CreatedAt == "asc" {
		baseQuery += " ORDER BY m.CreatedAt ASC"
	} else {
		baseQuery += " ORDER BY m.CreatedAt DESC"
	}

	// Add pagination
	baseQuery += fmt.Sprintf(" LIMIT $%d OFFSET $%d", counter, counter+1)
	args = append(args, arg.Limit, arg.Offset)

	rows, err := q.db.Query(ctx, baseQuery, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []MerchantQueryResult
	for rows.Next() {
		var r MerchantQueryResult
		if err := rows.Scan(
			&r.ID,
			&r.Name,
			&r.MerchantCategory,
			&r.ImageURL,
			&r.Lat,
			&r.Long,
			&r.CreatedAt,
		); err != nil {
			return nil, err
		}
		results = append(results, r)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return results, nil
}

func (q *Queries) CountMerchants(ctx context.Context, arg MerchantQueryParams) (int, error) {
	baseQuery := `
		SELECT COUNT(*)
		FROM Merchant m
	`

	counter := 1
	var conditions []string
	var args []interface{}

	// Filter by merchantId
	if arg.MerchantID != "" {
		conditions = append(conditions, fmt.Sprintf("m.ID = $%d", counter))
		args = append(args, arg.MerchantID)
		counter++
	}

	// Filter by name with wildcard search (case insensitive)
	if arg.Name != "" {
		conditions = append(conditions, fmt.Sprintf("LOWER(m.Name) LIKE LOWER($%d)", counter))
		args = append(args, "%"+arg.Name+"%")
		counter++
	}

	// Filter by merchantCategory
	if arg.MerchantCategory != "" {
		conditions = append(conditions, fmt.Sprintf("m.MerchantCategory = $%d", counter))
		args = append(args, arg.MerchantCategory)
		counter++
	}

	// Build WHERE clause
	if len(conditions) > 0 {
		baseQuery += " WHERE " + strings.Join(conditions, " AND ")
	}

	var total int
	err := q.db.QueryRow(ctx, baseQuery, args...).Scan(&total)
	return total, err
}

func (q *Queries) GetMerchantItem(ctx context.Context, arg MerchantItemParam) error {
	query := `-- name: GetMerchant :exec
	SELECT ID, Name, MerchantCategory, Location, CratedAt FROM MerchantItem
	`
	counter := 1 //will be used for dynamic param placement
	var conditions []string
	var args []interface{}

	if arg.ID != "" {
		conditions = append(conditions, fmt.Sprintf("ID = $%d", counter))
		args = append(args, arg.ID)
		counter++
	}

	if arg.Name != "" {
		conditions = append(conditions, fmt.Sprintf("Name = $%d", counter))
		args = append(args, arg.Name)
		counter++
	}
	if arg.MerchantID != "" {
		conditions = append(conditions, fmt.Sprintf("ID = $%d", counter))
		args = append(args, arg.MerchantID)
		counter++
	}
	if arg.ProductCategory != "" {
		conditions = append(conditions, fmt.Sprintf("ID = $%d", counter))
		args = append(args, arg.ProductCategory)
		counter++
	}
	if arg.Price != 0 {
		conditions = append(conditions, fmt.Sprintf("ID = $%d", counter))
		args = append(args, arg.Price)
		counter++
	}
	if arg.CreatedAt != "" {
		conditions = append(conditions, fmt.Sprintf("ID = $%d", counter))
		args = append(args, arg.CreatedAt)
		counter++
	}

	if len(conditions) > 0 {
		query += " WHERE "+ strings.Join(conditions, " AND ")
	}
	_, err := q.db.Exec(ctx, query, args...)
	return err
}