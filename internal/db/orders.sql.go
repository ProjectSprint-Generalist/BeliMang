// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCalculatedEstimate = `-- name: CreateCalculatedEstimate :one
INSERT INTO calculated_estimates (
  user_id, total_price, estimated_delivery_time_minutes, estimate_data
) VALUES (
  $1::uuid, $2, $3, $4
) RETURNING id
`

type CreateCalculatedEstimateParams struct {
	UserID                       pgtype.UUID
	TotalPrice                   int32
	EstimatedDeliveryTimeMinutes int32
	EstimateData                 []byte
}

func (q *Queries) CreateCalculatedEstimate(ctx context.Context, arg CreateCalculatedEstimateParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createCalculatedEstimate,
		arg.UserID,
		arg.TotalPrice,
		arg.EstimatedDeliveryTimeMinutes,
		arg.EstimateData,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  user_id, calculated_estimate_id
) VALUES (
  $1::uuid, $2::uuid
) RETURNING id
`

type CreateOrderParams struct {
	UserID               pgtype.UUID
	CalculatedEstimateID pgtype.UUID
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.UserID, arg.CalculatedEstimateID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getCalculatedEstimateByID = `-- name: GetCalculatedEstimateByID :one
SELECT 
  id,
  user_id,
  total_price,
  estimated_delivery_time_minutes,
  estimate_data,
  created_at
FROM calculated_estimates
WHERE id = $1::uuid
`

func (q *Queries) GetCalculatedEstimateByID(ctx context.Context, id pgtype.UUID) (CalculatedEstimate, error) {
	row := q.db.QueryRow(ctx, getCalculatedEstimateByID, id)
	var i CalculatedEstimate
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalPrice,
		&i.EstimatedDeliveryTimeMinutes,
		&i.EstimateData,
		&i.CreatedAt,
	)
	return i, err
}

const getOrdersByUserID = `-- name: GetOrdersByUserID :many
SELECT 
  o.id,
  o.created_at,
  ce.estimate_data
FROM orders o
JOIN calculated_estimates ce ON o.calculated_estimate_id = ce.id
WHERE o.user_id = $1::uuid
ORDER BY o.created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersByUserIDParams struct {
	Column1 pgtype.UUID
	Limit   int32
	Offset  int32
}

type GetOrdersByUserIDRow struct {
	ID           pgtype.UUID
	CreatedAt    pgtype.Timestamptz
	EstimateData []byte
}

func (q *Queries) GetOrdersByUserID(ctx context.Context, arg GetOrdersByUserIDParams) ([]GetOrdersByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getOrdersByUserID, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersByUserIDRow
	for rows.Next() {
		var i GetOrdersByUserIDRow
		if err := rows.Scan(&i.ID, &i.CreatedAt, &i.EstimateData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersCountByUserID = `-- name: GetOrdersCountByUserID :one
SELECT COUNT(*)
FROM orders o
WHERE o.user_id = $1::uuid
`

func (q *Queries) GetOrdersCountByUserID(ctx context.Context, dollar_1 pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getOrdersCountByUserID, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}
