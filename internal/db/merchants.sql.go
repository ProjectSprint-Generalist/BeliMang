// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: merchants.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMerchantItems = `-- name: CountMerchantItems :one
SELECT COUNT(*)
FROM merchant_items mi
WHERE mi.merchant_id = $1
  AND ($2::text IS NULL OR mi.id::text = $2)
  AND ($3::text IS NULL OR mi.product_category::text = $3)
  AND (
    $4::text IS NULL
    OR LOWER(mi.name) LIKE LOWER('%' || $4 || '%')
  )
`

type CountMerchantItemsParams struct {
	MerchantID      pgtype.UUID
	ItemID          pgtype.Text
	ProductCategory pgtype.Text
	Name            pgtype.Text
}

func (q *Queries) CountMerchantItems(ctx context.Context, arg CountMerchantItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchantItems,
		arg.MerchantID,
		arg.ItemID,
		arg.ProductCategory,
		arg.Name,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMerchants = `-- name: CountMerchants :one
SELECT COUNT(*)
FROM merchants m
WHERE
  ($1::text IS NULL OR m.id::text = $1)
  AND ($2::text IS NULL OR m.merchant_category::text = $2)
  AND (
    $3::text IS NULL
    OR LOWER(m.name) LIKE LOWER('%' || $3 || '%')
  )
`

type CountMerchantsParams struct {
	MerchantID       pgtype.Text
	MerchantCategory pgtype.Text
	Name             pgtype.Text
}

func (q *Queries) CountMerchants(ctx context.Context, arg CountMerchantsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMerchants, arg.MerchantID, arg.MerchantCategory, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMerchant = `-- name: CreateMerchant :one
INSERT INTO merchants (
  name, merchant_category, image_url, location
) VALUES (
  $1, $2, $3, ST_SetSRID(ST_MakePoint($4, $5), 4326)
) RETURNING id
`

type CreateMerchantParams struct {
	Name             string
	MerchantCategory MerchantCategory
	ImageUrl         string
	StMakepoint      interface{}
	StMakepoint_2    interface{}
}

func (q *Queries) CreateMerchant(ctx context.Context, arg CreateMerchantParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createMerchant,
		arg.Name,
		arg.MerchantCategory,
		arg.ImageUrl,
		arg.StMakepoint,
		arg.StMakepoint_2,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createMerchantItem = `-- name: CreateMerchantItem :one
INSERT INTO merchant_items (
  merchant_id, name, product_category, price, image_url
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id
`

type CreateMerchantItemParams struct {
	MerchantID      pgtype.UUID
	Name            string
	ProductCategory ProductCategory
	Price           int32
	ImageUrl        string
}

func (q *Queries) CreateMerchantItem(ctx context.Context, arg CreateMerchantItemParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createMerchantItem,
		arg.MerchantID,
		arg.Name,
		arg.ProductCategory,
		arg.Price,
		arg.ImageUrl,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getMerchantByID = `-- name: GetMerchantByID :one
SELECT EXISTS(SELECT 1 FROM merchants WHERE id = $1)
`

func (q *Queries) GetMerchantByID(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, getMerchantByID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getMerchantItems = `-- name: GetMerchantItems :many
SELECT
  mi.id,
  mi.name,
  mi.product_category,
  mi.price,
  COALESCE(mi.image_url, '') as image_url,
  mi.created_at
FROM merchant_items mi
WHERE mi.merchant_id = $1
  AND ($2::text IS NULL OR mi.id::text = $2)
  AND ($3::text IS NULL OR mi.product_category::text = $3)
  AND (
    $4::text IS NULL
    OR LOWER(mi.name) LIKE LOWER('%' || $4 || '%')
  )
ORDER BY
  CASE WHEN $5 = 'asc' THEN mi.created_at END ASC,
  CASE WHEN $5 = 'desc' THEN mi.created_at END DESC,
  mi.id ASC
LIMIT $7::int OFFSET $6::int
`

type GetMerchantItemsParams struct {
	MerchantID      pgtype.UUID
	ItemID          pgtype.Text
	ProductCategory pgtype.Text
	Name            pgtype.Text
	CreatedAt       interface{}
	OffsetVal       int32
	LimitVal        int32
}

type GetMerchantItemsRow struct {
	ID              pgtype.UUID
	Name            string
	ProductCategory ProductCategory
	Price           int32
	ImageUrl        string
	CreatedAt       pgtype.Timestamptz
}

func (q *Queries) GetMerchantItems(ctx context.Context, arg GetMerchantItemsParams) ([]GetMerchantItemsRow, error) {
	rows, err := q.db.Query(ctx, getMerchantItems,
		arg.MerchantID,
		arg.ItemID,
		arg.ProductCategory,
		arg.Name,
		arg.CreatedAt,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchantItemsRow
	for rows.Next() {
		var i GetMerchantItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProductCategory,
			&i.Price,
			&i.ImageUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchants = `-- name: GetMerchants :many
SELECT
  m.id,
  m.name,
  m.merchant_category,
  COALESCE(m.image_url, '') as image_url,
  ST_Y(m.location::geometry) as lat,
  ST_X(m.location::geometry) as long,
  m.created_at
FROM merchants m
WHERE
  ($1::text IS NULL OR m.id::text = $1)
  AND ($2::text IS NULL OR m.merchant_category::text = $2)
  AND (
    $3::text IS NULL
    OR LOWER(m.name) LIKE LOWER('%' || $3 || '%')
  )
ORDER BY
  CASE WHEN $4 = 'asc' THEN m.created_at END ASC,
  CASE WHEN $4 = 'desc' THEN m.created_at END DESC,
  m.id ASC
LIMIT $6::int OFFSET $5::int
`

type GetMerchantsParams struct {
	MerchantID       pgtype.Text
	MerchantCategory pgtype.Text
	Name             pgtype.Text
	CreatedAt        interface{}
	OffsetVal        int32
	LimitVal         int32
}

type GetMerchantsRow struct {
	ID               pgtype.UUID
	Name             string
	MerchantCategory MerchantCategory
	ImageUrl         string
	Lat              interface{}
	Long             interface{}
	CreatedAt        pgtype.Timestamptz
}

func (q *Queries) GetMerchants(ctx context.Context, arg GetMerchantsParams) ([]GetMerchantsRow, error) {
	rows, err := q.db.Query(ctx, getMerchants,
		arg.MerchantID,
		arg.MerchantCategory,
		arg.Name,
		arg.CreatedAt,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMerchantsRow
	for rows.Next() {
		var i GetMerchantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MerchantCategory,
			&i.ImageUrl,
			&i.Lat,
			&i.Long,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
