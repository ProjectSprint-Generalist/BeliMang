// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: nearby.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countNearbyMerchants = `-- name: CountNearbyMerchants :one
SELECT COUNT(*)
FROM merchants m
WHERE
  ($1::text IS NULL OR m.id::text = $1)
  AND ($2::text IS NULL OR m.merchant_category::text = $2)
  AND (
    $3::text IS NULL
    OR LOWER(m.name) LIKE LOWER('%' || $3 || '%')
    OR EXISTS (
      SELECT 1 FROM merchant_items mi
      WHERE mi.merchant_id = m.id
        AND LOWER(mi.name) LIKE LOWER('%' || $3 || '%')
    )
  )
`

type CountNearbyMerchantsParams struct {
	MerchantID       pgtype.Text
	MerchantCategory pgtype.Text
	Name             pgtype.Text
}

func (q *Queries) CountNearbyMerchants(ctx context.Context, arg CountNearbyMerchantsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countNearbyMerchants, arg.MerchantID, arg.MerchantCategory, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNearbyMerchants = `-- name: GetNearbyMerchants :many
SELECT
  m.id,
  m.name,
  m.merchant_category,
  COALESCE(m.image_url, '') AS image_url,
  ST_Y(m.location::geometry) AS lat,
  ST_X(m.location::geometry) AS long,
  m.created_at,
  ST_DistanceSphere(m.location, ST_SetSRID(ST_MakePoint($1, $2), 4326)) AS distance
FROM merchants m
WHERE
  ($3::text IS NULL OR m.id::text = $3)
  AND ($4::text IS NULL OR m.merchant_category::text = $4)
  AND (
    $5::text IS NULL
    OR LOWER(m.name) LIKE LOWER('%' || $5 || '%')
    OR EXISTS (
      SELECT 1 FROM merchant_items mi
      WHERE mi.merchant_id = m.id
        AND LOWER(mi.name) LIKE LOWER('%' || $5 || '%')
    )
  )
ORDER BY distance ASC, m.id ASC
LIMIT $7::int OFFSET $6::int
`

type GetNearbyMerchantsParams struct {
	Long             interface{}
	Lat              interface{}
	MerchantID       pgtype.Text
	MerchantCategory pgtype.Text
	Name             pgtype.Text
	RowOffset        int32
	RowLimit         int32
}

type GetNearbyMerchantsRow struct {
	ID               pgtype.UUID
	Name             string
	MerchantCategory MerchantCategory
	ImageUrl         string
	Lat              interface{}
	Long             interface{}
	CreatedAt        pgtype.Timestamptz
	Distance         interface{}
}

func (q *Queries) GetNearbyMerchants(ctx context.Context, arg GetNearbyMerchantsParams) ([]GetNearbyMerchantsRow, error) {
	rows, err := q.db.Query(ctx, getNearbyMerchants,
		arg.Long,
		arg.Lat,
		arg.MerchantID,
		arg.MerchantCategory,
		arg.Name,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNearbyMerchantsRow
	for rows.Next() {
		var i GetNearbyMerchantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MerchantCategory,
			&i.ImageUrl,
			&i.Lat,
			&i.Long,
			&i.CreatedAt,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
